# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 1.0.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14UKlbKh5NPsQiMfoHBfCg9kAa26ZYjE5

[Текст ссылки](https://)ФИО: Копьев Данила Александрович

# Задание (совместное с преподавателем)

Напишите систему для учёта отпусков с возможностью узнавать, сколько дней отпуска осталось у того или иного сотрудника.
Для этого создайте класс Employee со следующими методами:

- Метод consume_vacation должен отвечать за списание дней отпуска.

Единственный параметр этого метода (кроме self) — количество потраченных отпускных дней (целое число).

При вызове метода consume_vacation соответствующее количество дней должно вычитаться из общего числа доступных отпускных дней сотрудника.

Чтобы определить число доступных отпускных дней конкретного сотрудника, в классе опишите атрибут экземпляра |, который по умолчанию будет равен значению атрибута класса vacation_days, и используйте этот атрибут в работе метода.

- Метод get_vacation_details должен возвращать остаток отпускных дней сотрудника в формате: ```Остаток отпускных дней: <число>.```


Чтобы проверить работу программы:
1. Создайте экземпляр класса Employee.
2. Вызовите метод consume_vacation, указав подходящее значение аргумента, например 7.
3. Вызовите метод get_vacation_details.
"""

class Employee:
    vacation_days = 28

    def __init__(self, name, surname, gender):
        self.name = name
        self.surname = surname
        self.gender = gender
        self.remaining_vacation_days = self.vacation_days

    def consume_vacations(self, days):
        self.remaining_vacation_days -= days

    def get_vacation_details(self):
        return f'Остаток отпускных дней: {self.remaining_vacation_days}.'


employee1 = Employee('Иван', 'Коновалов', 'М')
employee2 = Employee('Анна', 'Пяткова', 'Ж')

print(f'{employee1.name} - {employee1.get_vacation_details()}')
print(f'{employee2.name} - {employee2.get_vacation_details()} \n')

print(employee1.name, 'уехал далеко и надолго на 9 дней.')
print(employee1.name, 'уехала далеко и надолго на 19 дней. \n')

employee1.consume_vacations(9)
employee2.consume_vacations(19)

print(employee1.get_vacation_details())
print(employee2.get_vacation_details())

"""# Задание 1

Задание:

Создайте класс с именем Rectangle который имеет:
- Атрибуты ширины и высоты.
- Метод расчета площади.
- Метод расчета периметра.
- Метод отображения размеров прямоугольника.

Создайте экземпляр класса Rectangleи продемонстрируйте его функциональность.
"""

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        area = self.width * self.height
        return area

    def calculate_perimeter(self):
        perimeter = 2 * self.width + 2 * self.height
        return perimeter

    def display_characteristics(self):
        print(f'Ширина прямоугольника = {self.width}, \n'
            f'Высота прямоугольника = {self.height} \n')
        return


rec_1 = Rectangle(25, 300)
rec_2 = Rectangle(300, 45)
#rec_1
print(f'Площадь прямоугольника равна {rec_1.calculate_area()} ед^2.')
print(f'Периметр прямоугольника равен {rec_1.calculate_perimeter()} ед.')
rec_1.display_characteristics()
#rec_2
print(f'Площадь прямоугольника равна {rec_2.calculate_area()} ед^2.')
print(f'Периметр прямоугольника равен {rec_2.calculate_perimeter()} ед.')
rec_2.display_characteristics()

"""# Задание 2

Задание: Создайте мини версию банковской системы:


Инструкции:

1. Создайте класс BankAccountсо следующими атрибутами:
    - account_holder -  владелец счета
    - balance - баланс счета

2. Реализуйте следующие методы:
    - Метод для инициализации владельца счета: имя владельца счета и установите начальный баланс на 0.
    - deposit(amount): Добавьте указанную сумму к балансу.
    - withdraw(amount): Вычесть указанную сумму из баланса, если средств достаточно; в противном случае вывести предупреждение.
    - get_balance(): Возврат текущего баланса.


Создайте объект класса и продемонстрируйте его возможности
"""

class BankAccount:
    balance = 0
    account_holder = 'Вадим Вадимович'

    def __init__(self):
        self.balance = self.balance
        self.account_holder = self.account_holder

    def deposit(self, amount):
        self.balance += amount

    def withdraw(self, amount):
        self.balance -= amount
        while self.balance < 0:
            self.balance += amount
            print('Обнаружена попытка вывести больше средств, \n'
                'чем находится на счету. ')
            amount = int(input('Введите сумму для вывода еще раз: '))
            self.balance -= amount

    def get_balance(self):
        return self.balance


def start():
    action = 0
    bank_account_base = BankAccount()

    while action != 4:
        action = int(input('Вас приветсвует мини версия банковской системы. \n'
            'Она способна выполнять следующие операции: \n\n'

            '1. Ввести денежную сумму на счет \n'
            '2. Снять денежную сумму со счета \n'
            '3. Показать баланс и владельца счета \n'
            '4. Выход \n\n'

            'Для выбора опции введите цифру нужной операции: '))

        if action == 1:
            amount = float(input('\nВведите сумму для пополнения счета: '))
            bank_account_base.deposit(amount)
            print(f'Счет успешно пополнен. Баланс счета: {bank_account_base.get_balance()}р. \n')
        elif action == 2:
            amount = float(input('\nВведите сумму для пополнения счета: '))
            bank_account_base.withdraw(amount)
            print(f'Со счета успешно списаны средства. Баланс счета: {bank_account_base.get_balance()}р. \n')
        elif action == 3:
            print(f'Баланс счета: {bank_account_base.get_balance()}р. \n'
                f'Владелец счета: {bank_account_base.account_holder}. \n')
        elif action == 4:
            break


if __name__ == '__main__':
    start()

"""# Задание 3

Возьмите код и задание (Рыцарь и дракон) из предыдущей практики и реализуйте его с применением классов
"""

import random

class Character:
    def __init__(self, name, health, armor, attack_min, attack_max):
        self.name = name
        self.health = health
        self.armor = armor
        self.attack_min = attack_min
        self.attack_max = attack_max

    def attack(self):
        damage = random.randint(self.attack_min, self.attack_max)
        print(f'{self.name} наносит {damage} урона!')
        return damage

    def take_damage(self, damage):
        if self.armor > 0:
            self.armor -= damage
            if self.armor < 0:
                self.health += self.armor
                self.armor = 0
        elif self.armor <= 0:
            self.armor = 0   # Устанавливаем броню в 0
            self.health -= damage
        self.health = max(0, self.health)

        print(f'{self.name} получает {damage} урона. Осталось здоровья: {self.health}, броня: {self.armor}')

    def is_alive(self):
        return self.health > 0


class Knight(Character):
    def __init__(self, name, armor, attack_min, attack_max, health):
        super().__init__(name, health, armor, attack_min, attack_max)


class Dragon(Character):
    def __init__(self, name, armor, health, attack_min, attack_max):
        super().__init__(name, health, armor, attack_min, attack_max)


def create_knights():
    return [
        Knight("Деревянный рыцарь", armor=100, attack_min=25, attack_max=40, health=200),
        Knight("Стальной рыцарь", armor=300, attack_min=15, attack_max=30, health=100),
        Knight("Бронзовый рыцарь", armor=200, attack_min=5, attack_max=20, health=300)
    ]


def create_dragons(difficulty):
    if difficulty == 'легкий':
        return Dragon("Легкий дракон", armor=100, health=500, attack_min=5, attack_max=10)
    elif difficulty == 'сложный':
        return Dragon("Сложный дракон", armor=250, health=750, attack_min=20, attack_max=30)


def battle(knight, dragon):
    print(f'\n{knight.name} vs {dragon.name}!\n')
    while knight.is_alive() and dragon.is_alive():
        action = input("Выберите действие: \n1. Ударить\n")
        if action == '1':
            damage_to_dragon = knight.attack()
            dragon.take_damage(damage_to_dragon)

            if not dragon.is_alive():
                print(f'\n{dragon.name} повержен! {knight.name} одержал победу!')
                break

            damage_to_knight = dragon.attack()
            knight.take_damage(damage_to_knight)

            if not knight.is_alive():
                print(f'\n{knight.name} повержен! {dragon.name} одержал победу!')
                break


def main():
    print('Добро пожаловать в игру "Рыцарь и Дракон"!')

    knights = create_knights()
    selected_knight = None
    selected_dragon = None

    while True:
        print("\n1. Начать бой \n"
              "2. Выбрать рыцаря \n"
              "3. Дать имя рыцарю \n"
              "4. Выбрать уровень сложности \n"
              "5. Дополнительное снаряжение \n"
              "6. Выход")

        choice = input("Выберите действие: ")

        if choice == '1':
            if selected_knight is None:
                print("Необходимо выбрать рыцаря перед началом боя.")
                continue
            elif selected_dragon is None:
                print("Необходимо выбрать дракона перед началом боя.")
                continue
            else:
                battle(selected_knight, selected_dragon)

        elif choice == '2':
            print("Выберите рыцаря:")
            for i, knight in enumerate(knights, start=1):
                print(f"{i}. {knight.name} | Здоровье: {knight.health} | Броня: {knight.armor} | Урон: {knight.attack_min}-{knight.attack_max}")
            knight_choice = int(input("Введите номер рыцаря: ")) - 1
            selected_knight = knights[knight_choice]
            print(f"Вы выбрали: {selected_knight.name}")

        elif choice == '3':
            if selected_knight:
                new_name = input(f"Введите новое имя для {selected_knight.name} (текущее: {selected_knight.name}): ")
                confirm = input(f"Вы уверены, что хотите изменить имя на '{new_name}'? (да/нет): ")
                if confirm.lower() == 'да':
                    selected_knight.name = new_name
                    print(f"Имя изменено на: {selected_knight.name}")
            else:
                print("Сначала выберите рыцаря.")

        elif choice == '4':
            print("Выберите уровень сложности:")
            print("1. Легкий дракон")
            print("2. Сложный дракон")
            difficulty_choice = input("Введите номер сложности: ")
            if difficulty_choice == '1':
                selected_dragon = create_dragons('легкий')
                print(f"Вы выбрали: {selected_dragon.name}")
            elif difficulty_choice == '2':
                selected_dragon = create_dragons('сложный')
                print(f"Вы выбрали: {selected_dragon.name}")

        elif choice == '5':
            print("Дополнительное снаряжение не реализовано.")

        elif choice == '6':
            print("Выход из игры.")
            break

        else:
            print("Неверный ввод, попробуйте снова.")


if __name__ == '__main__':
    main()

"""# Дополнительное задание

Задача: Система управления библиотекой

**Цель**
Создайте простую систему управления библиотекой, которая позволит пользователям добавлять книги, брать книги, возвращать книги и просматривать список доступных книг.

**Требования**

1. **Определение класса**:
   – Создайте класс с именем «Book» со следующими атрибутами:
     - `title`
     - `автор`
     - `isbn`
     - `is_borrowed` (по умолчанию `False`)

2. **Класс библиотеки**:
   - Создайте класс с именем Library, который управляет коллекцией книг.
   - Класс должен иметь следующие методы:
     - `__init__(self)`: инициализирует пустой список книг.
     - `add_book(self, book: Book)`: добавляет новую книгу в библиотеку.
     - `borrow_book(self, isbn: str)`: помечает книгу как заимствованную. Если книга не найдена или уже взята, выведите соответствующее сообщение.
     - `return_book(self, isbn: str)`: помечает книгу как возвращенную. Если книга не найдена или не была взята взаймы, выведите соответствующее сообщение.
     - `list_available_books(self)`: печатает список всех доступных книг в библиотеке.
     - `find_book(self, isbn: str)`: возвращает объект книги, если он найден, в противном случае возвращает `None`.

3. **Взаимодействие с пользователем**:
   - Создайте простое текстовое меню, которое позволит пользователям:
     - Добавить книгу
     - Одолжить книгу
     - Вернуть книгу
     - Список доступных книг
     - Выйти из программы
"""



