# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 0.9.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Y7Ni1tCiT0PgbKl90xkCWavFO33OKbb

ФИО
"""

Копьев Данила Александрович

"""# Дисклеймер

В данной практике вам необходимо применить все ваши знания по темам:

- Функции
- Словари
- Списки
- Множества
- Условные конструкции
- Запросы

и все что было изучено на прошлых практических занятиях

В каждом задании кратко описаны функции, которые необходимо реализовать, детали реализации вы должны продумать самостоятельно

# Задание 0

Создайте функцию по нахождению уникальных элементов из двух списков



```
a = [1, 2, 3, 4]
b = [3, 4, 5, 6]
```
"""

def unique_elements(a, b):
    set_a = set(a)
    set_b = set(b)

    unique_a = set_a - set_b
    unique_b = set_b - set_a

    unique_elements = unique_a.union(unique_b)

    return list(unique_elements)


a = [1, 2, 3, 4]
b = [3, 4, 5, 6]
result = unique_elements(a, b)
print(result)

"""# Задание 1

Симулятор виртуального питомца

Цель: создать виртуальный симулятор домашних животных, в котором пользователи смогут заводить питомцев и ухаживать за ними.

Требования:

- Функция для усыновления питомца (имя, тип, возраст).
- Функция для того, чтобы покормить питомца, поиграть с ним или уложить его спать.
- Функция для отображения состояния питомца (голод, радость, энергия).
"""

import random


class Pet:
    def __init__(self, name, pet_type, age):
        self.name = name
        self.pet_type = pet_type
        self.age = age
        self.hunger = random.randint(3, 6)  # Уровень голода от 3 до 6
        self.happiness = random.randint(1, 3)  # Уровень радости от 1 до 3
        self.energy = random.randint(2, 4)  # Уровень энергии от 2 до 4
        self.is_fed = False

    def feed(self, food):
        if self.is_fed:
            print(f'Питомец {self.name} сыт, есть не желает.')
            return
        self.hunger += random.randint(3, 6)
        self.happiness += random.randint(1, 3)
        self.energy += random.randint(2, 4)
        # Проверяем переполнение уровней
        self.hunger = min(self.hunger, 14)
        self.happiness = min(self.happiness, 14)
        self.energy = min(self.energy, 14)

        self.is_fed = True
        print(f'Вы покормили {self.name} ({self.pet_type}) едой: {food}.')

    def status(self):
        return (f'Имя: {self.name}, Тип: {self.pet_type}, Возраст: {self.age}, '
                f'Уровень голода: {self.hunger}, Уровень радости: {self.happiness}, '
                f'Уровень энергии: {self.energy}')


pets = []

def adopt_pet():
    name = input('Введите имя питомца: ')
    pet_type = input('Введите тип питомца (рыба, черепаха, хомяк): ')
    age = input('Введите возраст питомца: ')
    new_pet = Pet(name, pet_type, age)
    pets.append(new_pet)
    print(f'Вы усыновили питомца {name}!')


def feed_pet():
    name = input('Введите имя питомца, которого хотите покормить: ')
    food = input('Введите название еды для питомца: ')

    for pet in pets:
        if pet.name == name:
            pet.feed(food)
            return
    print('Питомец не найден.')


def view_pet_status():
    name = input('Введите имя питомца для просмотра состояния: ')

    for pet in pets:
        if pet.name == name:
            print(pet.status())
            return
    print('Питомец не найден.')


def main():
    print('Вас приветствует симулятор домашних животных.'
          'В нем можно: \n\n'
          '1. Усыновить питомца \n'
          '2. Покормить питомца \n'
          '3. Просмотреть состояние питомца \n'
          '4. Просмотреть своих питомцев \n'
          '0. Выход \n\n')

    while True:
        choice = input('Выберите действие: ')
        if choice == '1':
            adopt_pet()
        elif choice == '2':
            feed_pet()
        elif choice == '3':
            view_pet_status()
        elif choice == '4':
            for pet in pets:
                print(f'- {pet.name} ({pet.pet_type})')
        elif choice == '0':
            print('Выход из программы.')
            break
        else:
            print('Неверный выбор, попробуйте снова.')


if __name__ == '__main__':
    main()

"""# Задание 2

Рыцарь и дракон

Цель: создать небольшую игру, в которой вам необходимо играть за рыцаря и сразиться с драконом

Требования:

- Создание персонажа (имя, информация о доспехах, оружии, урон, здоровье)
- Управление персонажем и мини сюжет
- Создание дракона (Имя, информация о здоровье и уроне)
- Боевая система (нанесение и получение урона, урон должен быть случайным в заданном диапазоне)
- Реализовать бой между драконом и рыцарем
"""

import random

class Character:
    def __init__(self, name, health, armor, attack_min, attack_max):
        self.name = name
        self.health = health
        self.armor = armor
        self.attack_min = attack_min
        self.attack_max = attack_max

    def attack(self):
        damage = random.randint(self.attack_min, self.attack_max)
        print(f'{self.name} наносит {damage} урона!')
        return damage

    def take_damage(self, damage):
        if self.armor > 0:
            self.armor -= damage
            if self.armor < 0:
                self.health += self.armor
                self.armor = 0
        elif self.armor <= 0:
            self.armor = 0
            self.health -= damage
        self.health = max(0, self.health)

        print(f'{self.name} получает {damage} урона. Осталось здоровья: {self.health}, броня: {self.armor}')

    def is_alive(self):
        return self.health > 0


def create_characters():
    characters = []
    characters.append(Character("Деревянный рыцарь", 200, 100, 25, 40))
    characters.append(Character("Стальной рыцарь", 100, 300, 15, 30))
    characters.append(Character("Бронзовый рыцарь", 300, 200, 5, 20))
    characters.append(Character("Легкий дракон", 500, 100, 5, 10))
    characters.append(Character("Сложный дракон", 750, 250, 20, 30))
    return characters


def battle(character1, character2):
    print(f'\n{character1.name} vs {character2.name}!\n')
    while character1.is_alive() and character2.is_alive():
        action = input("Выберите действие: \n1. Ударить\n")
        if action == '1':
            damage_to_character2 = character1.attack()
            character2.take_damage(damage_to_character2)

            if not character2.is_alive():
                print(f'\n{character2.name} повержен! {character1.name} одержал победу!')
                break

            damage_to_character1 = character2.attack()
            character1.take_damage(damage_to_character1)

            if not character1.is_alive():
                print(f'\n{character1.name} повержен! {character2.name} одержал победу!')
                break


def main():
    print('Добро пожаловать в игру "Рыцарь и Дракон"!')

    characters = create_characters()
    selected_character = None
    selected_opponent = None

    while True:
        print("\n1. Начать бой \n"
              "2. Выбрать персонажа \n"
              "3. Выбрать противника \n"
              "4. Назначить имя персонажу \n"
              "5. Завершить игру")

        choice = input("Выберите действие: ")

        if choice == '1':
            if selected_character is None:
                print("Необходимо выбрать персонажа перед началом боя.")
                continue
            elif selected_opponent is None:
                print("Необходимо выбрать противника перед началом боя.")
                continue
            else:
                battle(selected_character, selected_opponent)

        elif choice == '2':
            print("Выберите персонажа:")
            for i, character in enumerate(characters, start=1):
                print(f"{i}. {character.name} | Здоровье: {character.health} | Броня: {character.armor} | Урон: {character.attack_min}-{character.attack_max}")
            character_choice = int(input("Введите номер персонажа: ")) - 1
            selected_character = characters[character_choice]
            print(f"Вы выбрали: {selected_character.name}")

        elif choice == '3':
            if selected_character:
                opponent_choice = int(input(f"Введите номер противника: "))
                selected_opponent = characters[opponent_choice]
                print(f"Вы выбрали: {selected_opponent.name}")
            else:
                print("Сначала выберите персонажа.")

        elif choice == '4':
            if selected_character:
                new_name = input(f"Введите новое имя для {selected_character.name} (текущее: {selected_character.name}): ")
                confirm = input(f"Вы уверены, что хотите изменить имя на '{new_name}'? (да/нет): ")
                if confirm.lower() == 'да':
                    selected_character.name = new_name
                    print(f"Имя изменено на: {selected_character.name}")
            else:
                print("Сначала выберите персонажа.")

        elif choice == '5':
            print("Выход из игры.")
            break

        else:
            print("Неверный ввод, попробуйте снова.")


if __name__ == '__main__':
    main()

"""# Задание 3

Цель - создать менеджера команды Pokémon, который позволит пользователям:

- Добавлять покемонов в свою команду. (если такого покемона еще нет в команде)
- Удалять покемонов из их команды.
- Просматривать подробную информацию обо всех покемонах в команде.
- Находить покемона по имени.
- Устраивать тренировочный бой между двумя покемонами

Для данной задачи используйте: https://pokeapi.co/
"""

import requests

class PokemonManager:
    def __init__(self):
        self.team = []

    def add_pokemon(self, pokemon_name):
        # Проверяем, есть ли такой покемон в команде
        if any(pokemon['name'] == pokemon_name for pokemon in self.team):
            print(f"Покемон {pokemon_name} уже в вашей команде!")
            return

        # Получаем информацию о покемоне из API
        response = requests.get(f"https://pokeapi.co/api/v2/pokemon/{pokemon_name.lower()}")
        if response.status_code == 200:
            data = response.json()
            pokemon_info = {
                'name': data['name'],
                'id': data['id'],
                'types': [type_['type']['name'] for type_ in data['types']]
            }
            self.team.append(pokemon_info)
            print(f"Покемон {pokemon_name} успешно добавлен в вашу команду!")
        else:
            print(f"Не удалось добавить покемона {pokemon_name} в команду.")

    def remove_pokemon(self, pokemon_name):
        # Проверяем, есть ли такой покемон в команде
        found_index = next((i for i, pokemon in enumerate(self.team) if pokemon['name'] == pokemon_name), None)
        if found_index is not None:
            del self.team[found_index]
            print(f"Покемон {pokemon_name} был удалён из вашей команды.")
        else:
            print(f"Покемон {pokemon_name} не найден в вашей команде.")

    def view_team(self):
        if not self.team:
            print("Ваша команда пуста.")
            return

        print("Покемоны в вашей команде:")
        for pokemon in self.team:
            print(f"- Имя: {pokemon['name'].title()} | ID: {pokemon['id']} | Типы: {', '.join(pokemon['types'])}")

    def find_pokemon_by_name(self, pokemon_name):
        found_pokemon = next((pokemon for pokemon in self.team if pokemon['name'] == pokemon_name), None)
        if found_pokemon:
            print(f"Информация о покемоне {pokemon_name}:")
            print(f"Имя: {found_pokemon['name'].title()} | ID: {found_pokemon['id']} | Типы: {', '.join(found_pokemon['types'])}")
        else:
            print(f"Покемон {pokemon_name} не найден в вашей команде.")

    def train_fight(self, pokemon1_name, pokemon2_name):
        # Проверяем, есть ли такие покемоны в команде
        found_pokemon1 = next((pokemon for pokemon in self.team if pokemon['name'] == pokemon1_name), None)
        found_pokemon2 = next((pokemon for pokemon in self.team if pokemon['name'] == pokemon2_name), None)

        if found_pokemon1 and found_pokemon2:
            print(f"Тренировочный бой между {found_pokemon1['name'].title()} и {found_pokemon2['name'].title()} начался!")
            # Простейший алгоритм боя: сравнение типов покемонов
            types1 = set(found_pokemon1['types'])
            types2 = set(found_pokemon2['types'])
            common_types = types1.intersection(types2)

            if common_types:
                print(f"Оба покемона имеют общие типы: {', '.join(common_types)}. Бой завершился ничьей.")
            elif len(types1.difference(types2)) > len(types2.difference(types1)):
                print(f"{found_pokemon1['name'].title()} победил!")
            else:
                print(f"{found_pokemon2['name'].title()} победил!")
        else:
            print("Один или оба покемона не найдены в вашей команде.")

def main():
    manager = PokemonManager()

    while True:
        print("\nМенеджер команды Pokémon")
        print("1. Добавить покемона в команду")
        print("2. Удалить покемона из команды")
        print("3. Просмотреть информацию о покемонах в команде")
        print("4. Найти покемона по имени")
        print("5. Устроить тренировочный бой")
        print("6. Выход")

        choice = input("Введите номер действия: ")

        if choice == '1':
            pokemon_name = input("Введите имя покемона для добавления: ")
            manager.add_pokemon(pokemon_name)
        elif choice == '2':
            pokemon_name = input("Введите имя покемона для удаления: ")
            manager.remove_pokemon(pokemon_name)
        elif choice == '3':
            manager.view_team()
        elif choice == '4':
            pokemon_name = input("Введите имя покемона для поиска: ")
            manager.find_pokemon_by_name(pokemon_name)
        elif choice == '5':
            pokemon1_name = input("Введите имя первого покемона: ")
            pokemon2_name = input("Введите имя второго покемона: ")
            manager.train_fight(pokemon1_name, pokemon2_name)
        elif choice == '6':
            print("До свидания!")
            break
        else:
            print("Неправильный выбор. Попробуйте снова.")

if __name__ == "__main__":
    main()

3